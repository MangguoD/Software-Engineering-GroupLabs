```
     ┌───────────────────────────────────────────────────────────┐
263: │ std::string Lab1::calcShortestPath(const DirectedGraph &G,│
264: │                 const std::string &src,                   │
265: │                 const std::string &dst) {                 │
     └────────────┬──────────────────────────────────────────────┘
                  │
                  │
     ┌────────────▼────────────┐
266: │ if (!G.hasNode(src) ||  │───►【分支A】节点不存在──► return "No such nodes in graph!"; (L267)
     │     !G.hasNode(dst))    │
     └────────────┬────────────┘
                  │否
                  │
     ┌────────────▼─────────────────────────┐
268: │ const int INF =                      │
     │     std::numeric_limits<int>::max(); │
     └────────────┬─────────────────────────┘
                  │
     ┌────────────▼─────────────────┐
269: │ 初始化 dist[u]=INF for all u; │
270: │ dist[src]=0;                 │
     └──────────────────────────────┘
                  │
     ┌────────────▼────────────────────────┐
271: │ using P = std::pair<int,std::string>│
272: │ auto cmp = …;                       │
273: │ std::priority_queue<P,…> pq(cmp);   │
274: │ pq.push({0, src});                  │
     └─────────┬───────────────────────────┘
               │
     ┌─────────▼─────────────┐
275: │ while (!pq.empty()) { │ 
     └─────────┬─────────────┘
               │
     ┌─────────▼─────────┐
276: │ auto [d,u] = pq.top(); pq.pop(); │
     └─────────┬─────────┘
               │
     ┌─────────▼─────────┐
277: │ if (d > dist[u])  │───► continue (跳过过期条目)  │
     └─────────┬─────────┘
               │否
     ┌─────────▼─────────┐
278: │ if (u == dst)     │───► break (找到目标，跳出循环) │
     └─────────┬─────────┘
               │否
     ┌─────────▼──────────────────────────┐
279: │ for (auto &e : G.outgoing(u)) {    │
280: │   v=e.first; w=e.second;           │
281: │   if (dist[u]+w < dist[v]) {       │
282: │     dist[v]=dist[u]+w;             │
283: │     prev[v]=u;                     │
284: │     pq.push({dist[v], v});         │
285: │   }                                │
286: │ }                                  │
     └────────────┬───────────────────────┘
                  │
        (回到 while 起点 L275)
                  │
        当 pq 为空 或 break
                  │
     ┌────────────▼────────────┐
287: │ if (dist[dst] == INF)   │───► return "Unreachable!"; │
     └────────────┬────────────┘
                  │否
     ┌────────────▼───────────────┐
288: │ // 重建路径                 │
289: │ for (std::string at=dst; …)│
290: │   path.push_back(at);      │
291: │   if (at==src) break;      │
292: │ }                          │
293: │ std::reverse(path.begin(), │
294: │              path.end());  │
     └────────────┬───────────────┘
                  │
     ┌────────────▼────────────┐
295: │ // 格式化输出             │
296: │ oss<<"Path: ...";       │
297: │ oss<<"\nLength: "<<dist;│
     └────────────┬────────────┘
                  │                   
298:       return oss.str();
```